
# ============================================================
# app.py ‚Äî JD Validator + ATS Tracker (FULL, NO REDUCTIONS)
# ============================================================

import streamlit as st
import boto3
import os
import json
import re
import uuid
from io import BytesIO
from datetime import datetime
from dotenv import load_dotenv, find_dotenv
from botocore.config import Config
import fitz  # PyMuPDF

try:
    from pptx import Presentation
except Exception:
    Presentation = None

# ============================================================
# ENV (UNCHANGED)
# ============================================================

load_dotenv(find_dotenv())

AWS_ACCESS_KEY = os.getenv("AWS_ACCESS_KEY")
AWS_SECRET_KEY = os.getenv("AWS_SECRET_KEY")
AWS_REGION = os.getenv("AWS_REGION", "us-east-1")
S3_BUCKET = os.getenv("S3_BUCKET")
MODEL_ID = os.getenv("GEN_MODEL_ID") or os.getenv("INFERENCE_PROFILE_ARN")

if not all([AWS_ACCESS_KEY, AWS_SECRET_KEY, AWS_REGION, S3_BUCKET, MODEL_ID]):
    st.error("Missing AWS / Bedrock configuration")
    st.stop()

STAGES = ["Applied", "In Progress", "Interview Scheduled", "Selected", "Rejected"]

# ============================================================
# AWS CLIENTS
# ============================================================

cfg = Config(retries={"max_attempts": 10, "mode": "standard"})

s3 = boto3.client(
    "s3",
    aws_access_key_id=AWS_ACCESS_KEY,
    aws_secret_access_key=AWS_SECRET_KEY,
    region_name=AWS_REGION,
    config=cfg
)

bedrock = boto3.client(
    "bedrock-runtime",
    aws_access_key_id=AWS_ACCESS_KEY,
    aws_secret_access_key=AWS_SECRET_KEY,
    region_name=AWS_REGION,
    config=cfg
)

# ============================================================
# TEXT EXTRACTION
# ============================================================

def extract_pdf(data: bytes) -> str:
    doc = fitz.open(stream=data, filetype="pdf")
    return "\n".join(p.get_text() for p in doc).strip()

def extract_pptx(data: bytes) -> str:
    if not Presentation:
        return ""
    prs = Presentation(BytesIO(data))
    text = []
    for slide in prs.slides:
        for shape in slide.shapes:
            if hasattr(shape, "text") and shape.text.strip():
                text.append(shape.text.strip())
    return "\n".join(text).strip()

# ============================================================
# JSON PARSING (ROBUST)
# ============================================================

def parse_json_safe(text: str) -> dict:
    text = re.sub(r"```(?:json)?|```", "", text, flags=re.I).strip()
    try:
        return json.loads(text)
    except Exception:
        match = re.search(r"\{.*\}", text, flags=re.S)
        if match:
            return json.loads(match.group(0))
    return {}

# ============================================================
# LLM CALL (UNCHANGED)
# ============================================================

def call_llm(prompt: str) -> dict:
    response = bedrock.converse(
        modelId=MODEL_ID,
        messages=[
            {
                "role": "user",
                "content": [{"text": "Return STRICT JSON only.\n\n" + prompt}]
            }
        ],
        inferenceConfig={"temperature": 0.0, "maxTokens": 1024}
    )
    raw = response["output"]["message"]["content"][0]["text"]
    return parse_json_safe(raw)

# ============================================================
# PROMPT (UNCHANGED)
# ============================================================

PROMPT = """
You are a strict recruiter assistant.

Job Description:
{jd}

Candidate Resume:
{resume}

Return EXACTLY one JSON object:
{{
  "person_name": "",
  "decision": "MATCH | PARTIAL_MATCH | NO_MATCH",
  "score": 0,
  "llm_summary": "",
  "matched_requirements": [],
  "missing_requirements": []
}}
"""

# ============================================================
# SESSION STATE
# ============================================================

if "page" not in st.session_state:
    st.session_state.page = "home"

if "selected_app" not in st.session_state:
    st.session_state.selected_app = None

# ============================================================
# HOME PAGE ‚Äî FULL DETAIL RENDERING
# ============================================================

if st.session_state.page == "home":
    st.title("üìÑ JD Validator")

    if st.button("üìä View Application Status"):
        st.session_state.page = "status"
        st.rerun()

    jd = st.text_area("Paste Job Description", height=150)
    resumes = st.file_uploader(
        "Upload resumes (PDF / PPTX)",
        type=["pdf", "pptx"],
        accept_multiple_files=True
    )

    if st.button("Run Validation"):
        if not jd.strip() or not resumes:
            st.error("JD and resumes are required")
            st.stop()

        run_id = str(uuid.uuid4())[:8]

        for f in resumes:
            data = f.read()
            resume_text = extract_pdf(data) if f.name.lower().endswith(".pdf") else extract_pptx(data)

            llm = call_llm(PROMPT.format(jd=jd, resume=resume_text))

            raw_decision = llm.get("decision", "NO_MATCH").upper()
            raw_score = int(llm.get("score", 0))

            # -------- ORIGINAL PERCENTAGE ENFORCEMENT --------
            if raw_decision == "MATCH":
                score = max(raw_score, 80)
                decision = "MATCH"
            elif raw_decision == "PARTIAL_MATCH":
                score = max(21, min(raw_score, 79))
                decision = "PARTIAL_MATCH"
            else:
                score = 0
                decision = "NO_MATCH"

            if score <= 20:
                score = 0
                decision = "NO_MATCH"

            result = {
                "run_id": run_id,
                "resume_name": f.name,
                "person_name": llm.get("person_name", ""),
                "decision": decision,
                "score": score,
                "summary": llm.get("llm_summary", ""),
                "matched_requirements": llm.get("matched_requirements", []),
                "missing_requirements": llm.get("missing_requirements", []),
                "stage": "Applied",
                "hr_comments": "",
                "created_at": datetime.utcnow().isoformat()
            }

            s3.put_object(Bucket=S3_BUCKET, Key=f"applications/{run_id}/{f.name}", Body=data)
            s3.put_object(
                Bucket=S3_BUCKET,
                Key=f"applications/{run_id}/result.json",
                Body=json.dumps(result).encode()
            )

            # -------- HUMAN-READABLE UI (RESTORED) --------
            st.success(f"{f.name} ‚Äî {decision} ({score}%)")

            st.markdown("**Summary**")
            st.write(result["summary"] or "No summary provided")

            st.markdown("**Matched Requirements**")
            if result["matched_requirements"]:
                for r in result["matched_requirements"]:
                    st.markdown(f"- ‚úÖ {r}")
            else:
                st.markdown("- None")

            st.markdown("**Missing Requirements**")
            if result["missing_requirements"]:
                for r in result["missing_requirements"]:
                    st.markdown(f"- ‚ùå {r}")
            else:
                st.markdown("- None")

            st.divider()

# ============================================================
# STATUS PAGE ‚Äî ATS TABLE + SIDE PANEL
# ============================================================

def load_all_results():
    apps = []
    objs = s3.list_objects_v2(Bucket=S3_BUCKET, Prefix="applications/").get("Contents", [])
    for o in objs:
        if o["Key"].endswith("result.json"):
            data = json.loads(s3.get_object(Bucket=S3_BUCKET, Key=o["Key"])["Body"].read())
            data.setdefault("stage", "Applied")
            data.setdefault("hr_comments", "")
            apps.append(data)
    return apps

def save_result(run_id, data):
    s3.put_object(
        Bucket=S3_BUCKET,
        Key=f"applications/{run_id}/result.json",
        Body=json.dumps(data).encode()
    )

def presigned_url(key):
    return s3.generate_presigned_url(
        "get_object",
        Params={"Bucket": S3_BUCKET, "Key": key},
        ExpiresIn=600
    )

if st.session_state.page == "status":
    st.title("üìä Application Status")

    if st.button("‚¨Ö Back"):
        st.session_state.page = "home"
        st.session_state.selected_app = None
        st.rerun()

    results = load_all_results()

    header = st.columns([2, 3, 1, 1, 2, 1])
    header[0].markdown("**Candidate**")
    header[1].markdown("**Resume**")
    header[2].markdown("**Match %**")
    header[3].markdown("**Decision**")
    header[4].markdown("**Stage**")
    header[5].markdown("**Details**")

    for r in results:
        row = st.columns([2, 3, 1, 1, 2, 1])
        row[0].write(r["person_name"])
        row[1].write(r["resume_name"])
        row[2].write(f"{r['score']}%")
        row[3].write(r["decision"])

        stage = row[4].selectbox(
            "",
            STAGES,
            index=STAGES.index(r["stage"]),
            key=f"stage_{r['run_id']}"
        )
        if stage != r["stage"]:
            r["stage"] = stage
            save_result(r["run_id"], r)

        if row[5].button("View", key=f"view_{r['run_id']}"):
            st.session_state.selected_app = r

    # -------- SIDE PANEL (DETAILS) --------
    if st.session_state.selected_app:
        st.divider()
        app = st.session_state.selected_app

        st.subheader("Candidate Details")
        st.write(f"**Name:** {app['person_name']}")
        st.write(f"**Decision:** {app['decision']} ({app['score']}%)")

        resume_key = f"applications/{app['run_id']}/{app['resume_name']}"
        url = presigned_url(resume_key)

        if app["resume_name"].lower().endswith(".pdf"):
            st.markdown(
                f'<iframe src="{url}" width="100%" height="500"></iframe>',
                unsafe_allow_html=True
            )
        else:
            st.link_button("Download Resume", url)

        st.markdown("**Summary**")
        st.write(app["summary"])

        st.markdown("**Matched Requirements**")
        for m in app["matched_requirements"]:
            st.markdown(f"- ‚úÖ {m}")

        st.markdown("**Missing Requirements**")
        for m in app["missing_requirements"]:
            st.markdown(f"- ‚ùå {m}")

        comments = st.text_area("HR Comments", app.get("hr_comments", ""))
        if st.button("Save Comments"):
            app["hr_comments"] = comments
            save_result(app["run_id"], app)
            st.success("Comments saved")

        if st.button("Close"):
            st.session_state.selected_app = None
            st.rerun()
